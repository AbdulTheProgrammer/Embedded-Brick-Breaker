# Embedded-Brick-Breaker
The project was developed for the Keil MCB1700 evaluation board and used the Kiel RTOS.  Various synchronization techniques using semaphores and mutexes were employed to manage CPU resources in this memory constrained enviroment. Furthermore. this project also uses a modified version of the GLCD display driver, which was altered to meet the requirements of the design. The peripherals used for the Brick Breaker game are a joystick, push buttons, multiple LEDs indicating the current ball speed and the LCD display

### How it works:
This game system uses three different tasks that execute independent of one other. The first task polls for any change in direction of joystick. If a change is detected, it updated the positions of the paddle correspondingly. The second task deals with the movement of the ball based on the current speed. After a specified amount of time is passed corresponding to the current speed, the balls position is automatically updated. This task  also checks for any collision that the ball makes with the bricks in the game or with the edges of the display before updating the position of the ball. This task is also responsible for rerending the LCD display by calling the appropirate device driver functions. Furthermore, if a collision with a brick is detected, this task posts to a kill detection semaphore. Once the kill detection semaphore is posted to, this unblocks the last task used in the game. The last task in this game relates to re-rendering the bricks once a brick is destroyed. This task waits on the kill detection semaphore, determines which brick(s) were destroyed by the user and stores the new brick arrangement.  Finally, the speed of the game using the INT0 pushbutton must be controlled with a separate hardware interrupt, which required some debouncing. 

